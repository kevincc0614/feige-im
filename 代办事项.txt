代办事项

2.ID生成
3.HTTPS证书


BUG
1.服务器重启之后,用户未重连到新的服务器,缓存还存的是老的服务器地址,并显示在线。
这个时候会通过MQ发送离线消息过去,但是用户实际却是无法收到的


发布订阅模型


1.消息未确认,导致丢失的问题
①Push只发通知,不发具体消息
②客户端收到新消息通知,比对消息ID,比现存的大的就主动去拉取。从后往前翻页,直到查询到有重复为止。
③拉取完之后,Ack确认,更新设备指针



2.多端同步问题
3.大量离线消息


其一，我们对于单客户端情况下，用户同步库做了一个checkpoint点的持久化，对应的概念是：“已读最新消息的sequenceId”。此时，checkpoint点无客户端的区分，如果使用本地做持久化，多端同步时就会出现问题，不同客户端统计的未读消息数就会不一致。这是需要通过应用服务端维护checkpoint点，同时会话的未读消息数也需要在应用服务侧维护，这样才能保证多端统计数一致。同时，当有未读消息的会话被点击，会话未读数清0时，要让服务有感知，然后通知到其他在线端，维护实时一致性。

其二，多端情况下，自己在一个客户端发送了新消息，其他客户端在没有其他新消息时，是无法感知并刷新自己的发送消息，这在多端同步中也是要解决的小问题。这时，简单的解决方案就是将自己发送的消息，也写入自己的同步库。只要再统计未读信息时，对自己的信息不计数，但在最新消息摘要中需要做更新。这样，多端同步问题很容易实现。



多终端漫游可不可以这样呢？
在前面提到，为了保证消息的时序，采用全局自增序列，我建议把这个序列号存入服务端和客户端的消息表中。当用户上线时，将本设备最新的序列号发送给服务端，服务端将这个序列号与自己表中的数据比较，大于这个序列号的所有消息都是此设备需要接收的消息，这样也不需要单独维护离线消息
作者回复: 如之前的回答，多终端消息漫游的情况，这个时候可能推送的不仅仅是消息，还可能是一些操作的信令，这些信令一般不会进行持久化，如果只是获取消息可能会丢掉这些信令。
